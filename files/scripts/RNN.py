# !/usr/bin/python3
#coding: utf-8

"""TestRNN_Colab.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GVJgpRpaW3mrTAhiDv0SG9jxqUey2-q4
"""

txt = "Le saumon est « anadrome » (migrateur pour se reproduire), amphibiotique (adapté à la vie dans deux milieux aquatiques), potamotoque (il se reproduit en rivière) et thalassotrophe (il grandit en mer) : il naît en eau douce en eaux courantes près des sources, puis descend instinctivement jusqu'à la mer où il vit 1 à 3 ans, puis retourne dans le fleuve dans lequel il est né (phénomène dénommé « Homing ») pour frayer (se reproduire) et généralement mourir après la ponte (certaines populations de quelques espèces peuvent cependant passer toute leur vie en eau douce).Ce cycle implique de profondes modifications physiologiques permettant une adaptation au large gradient de salinité auquel chaque individu doit s'adapter de sa naissance à sa mort. Il implique aussi une capacité (hormonale et de perception des modifications environnementales) lui permettant de migrer à la saison convenant le mieux à la « montaison » et à la reproduction8. Le suivi de biomarqueurs de stress chez des populations différentes remontant des cours d'eau différents montre des différences entre populations, avec un niveau de stress souvent corrélé avec le taux d'échecs dans la montaison et à la mortalité lors de celle-ci.Les reproducteurs meurent habituellement après la ponte, mais quelques mâles du saumon royal ou saumon chinook tout comme le saumon atlantique (Salmo salar) retournent en mer et participent une seconde fois à la reproduction. Poussé par son instinct, chaque saumon parcourt des milliers de kilomètres et remonte même de tout petits ruisseaux. Certains franchissent des cascades de trois mètres ou traversent des routes en profitant des inondations. Même en l'absence d'obstacle physique et hors de la prédation naturelle, de nombreux poissons meurent durant la remontée, probablement parce qu'affaiblis ou perturbés par la pollution de l'eau, en raison d'une pollution génétique (croisement avec des saumons d'élevages qui se sont enfuis dans la nature) et/ou en raison de difficultés de régulation osmotique. Une fois sur le lieu de ponte (la frayère), la femelle creuse des dépressions dans le gravier avec sa queue. Quand elle pond, le mâle émet son sperme. Les saumons forment des couples, le mâle cherchant à éloigner les autres mâles de la femelle. La femelle recouvre ensuite les œufs de graviers, les mettant ainsi à l'abri des prédateurs, avant de mourir (comme le mâle en général). Les œufs pondus à l'automne passent l'hiver dans le gravier, oxygénés par l'eau froide et courante. L'éclosion a lieu en mars ou en avril, selon la température. Les alevins s'enfouissent alors un peu plus profondément dans le gravier, ce qui leur évite d'être emportés lors de la débâcle printanière. Ils y demeurent 5 à 6 semaines, se nourrissant du contenu de leur sac vitellin. Fin avril, début mai, les alevins émergent du gravier et commencent à s'alimenter de plancton et larves d'insectes. Ils fréquentent les endroits où la rivière est peu profonde et le courant important (radiers, sub-affleurements…). Ils profitent alors de la nourriture indirectement issue du « recyclage » des cadavres (nécromasse) de leurs géniteurs. Les bactéries et microchampignons prolifèrent en biofilms riches en oligoéléments rapportés de la mer (dont iode, qui eux-mêmes alimentent des microinvertébrés et/ou des macroinvertébrés dulcicoles qui seront la nourriture des alevins12. Les cadavres de saumons géniteurs étaient autrefois si nombreux que les vertébrés nécrophages ne pouvaient en consommer qu'une petite partie. On a comparé en Alaska le biofilm naturel et la biomasse de macroinvertébrés d'un cours d'eau où étaient venus pondre environ 75 000 saumons adultes et une partie du cours d'eau situé en amont de la frayère. En aval de cette dernière et après la mort des reproducteurs, la masse sèche de biofilm était 15 fois plus élevée qu'en amont de la frayère12, et la densité totale en macroinvertébrés était jusqu'à 25 fois supérieure dans les zones enrichie par les cadavres de saumons12. Dans ce cas, (saumons morts à demi-immergés dans une eau peu profonde et bien oxygénée), ces macroinvertébrés benthiques d'eau douce étaient principalement des moucherons chironomidés, des éphémères (Baetis et Cinygmula) ainsi que des perles. À la fin du premier été, les alevins mesurent environ 5 cm et sont nommés « tacons » ; très semblables physiquement à leurs cousines les truitelles, qui fréquentent les mêmes habitats. Après un à deux ans les jeunes saumons d'environ 15 cm sont prêts à s'en aller en mer. Il semblerait que c'est à ce moment, durant la smoltification (acquisition de la capacité à vivre en milieu salé) que le saumoneau mémorise l'odeur et le goût de sa rivière. Lors des crues du printemps les pré-smolts ou smolts dévalent vers la mer. Certains, trop en retard, n'iront pas au-delà de l'estuaire, leur capacité à vivre en mer ayant disparu, ils resteront en eau douce une année supplémentaire et partiront enfin en mer en temps opportun. Les juvéniles peuvent arriver relativement précocement en mer (ils ne pèsent alors que 0,3 g) avant même le plein développement de leurs adaptations physiologique à la vie en mer (par rapport à d'autres salmonidés anadromes). Ils vivent alors plutôt dans les deux premiers mètres de la colonne d'eau (eaux souvent un peu moins salées en aval des estuaires)13. Ils sont alors très voraces et grandissent rapidement (jusqu'à un doublement mensuel de sa masse corporelle chez le saumon rose en mer les deux premiers mois, après quoi le saumon est parfaitement adapté à la vie en mer). Le juvénile est habituellement très résilient aux maladies infectieuses et même aux parasitoses par le pou du saumon, dont il se débarrasse facilement aux stades copépodites14 (4e mue du pou du saumon). Les saumons sont capables de parcourir des centaines de kilomètres en remontant des rivières. En France, le Salmo salar atlantique de Loire-Allier parcourt presque 1 000 km pour atteindre les frayères du Haut-Allier). La construction de grands barrages modernes a coupé de nombreux cours d'eau, mais des échelles à saumon ont peu à peu été installées pour permettre aux migrateurs de franchir ces obstacles. Une mortalité par épuisement à cause d'une mauvaise qualité de l'eau et d'obstacles encore trop difficiles à franchir (et parfois d'une faible profondeur d'eau à l'approche des frayères) est notablement élevée ; dans la nature et plus encore dans certains cours d'eau artificialisés, ceux qui réussissent à remonter sont souvent blessés (bouche, abdomen...). Dans les zones sauvages nord-américaines, la prédation par les ours, lynx, loups, aigles pêcheurs et autres animaux lors de la remontée était également autrefois très importante, mais elle restait très faible au regard du nombre total de géniteurs. Elle jouait probablement un rôle en matière de sélection naturelle.La Lune, ou Terre I est l'unique satellite naturel permanent de la planète Terre. Il s'agit du cinquième plus grand satellite naturel du Système solaire et du plus grand des satellites planétaires par rapport à la taille de la planète autour de laquelle il orbite. Elle est le deuxième satellite le plus dense du Système solaire après Io, un satellite de Jupiter. La Lune est en rotation synchrone avec la Terre, lui montrant donc constamment la même face. Celle-ci, appelée face visible, est marquée par des mers lunaires volcaniques sombres qui remplissent les espaces entre les hautes terres claires — certaines atteignant 9 km d'altitude — et ses cratères d'impact proéminents. Réciproquement, elle possède une face cachée, qui présente moins de mers mais beaucoup plus de cratères, dont le bassin Pôle Sud-Aitken, le plus grand du satellite et l'un des plus grands du Système solaire par son diamètre de 2 500 km. Elle est dépourvue d'atmosphère dense et de champ magnétique. Son influence gravitationnelle sur la Terre produit les marées océaniques, les marées terrestres, un léger allongement de la durée du jour et la stabilisation de l'inclinaison de l'axe terrestre. La distance orbitale moyenne de la Lune est de 384 402 km, soit environ trente fois le diamètre terrestre, et sa période de révolution vaut 27,3 jours. La taille apparente de la Lune dans le ciel est approximativement la même que celle du Soleil, puisque le diamètre de l'étoile est environ 400 fois celui du satellite, mais qu'elle est également 400 fois plus éloignée. Par conséquent, la Lune peut couvrir presque exactement le Soleil dans le ciel, permettant l'apparition d'éclipses solaires totales. Cette correspondance de taille apparente disparaîtra dans un avenir lointain du fait de l'augmentation de la distance lunaire d'environ 3,8 cm par an. La formation de la Lune remonterait à il y a environ 4,51 milliards d'années, peu de temps après celle de la Terre. L'explication la plus largement acceptée est que la Lune s'est formée à partir des débris restants après un impact géant entre une proto-Terre et une protoplanète de la taille de Mars, appelée Théia. Le satellite naturel est survolé pour la première fois par la sonde spatiale Luna 2 en 1959. Durant plus d'une décennie, elle est notamment étudiée par les programmes Luna et Apollo, respectivement soviétique et américain. Cette course à l'espace culmine en 1969 avec les premiers humains posant le pied sur la Lune lors de la mission Apollo 11 emportant Neil Armstrong et Buzz Aldrin. Dix autres astronautes de la NASA foulent ensuite le sol lunaire jusqu'à Apollo 17 en 1972. Ces missions permettent de ramener sur Terre des roches lunaires qui, avec les observations effectuées sur place, permettent de développer la connaissance géologique de la Lune, de sa structure interne et de l'histoire de sa formation. Délaissée à partir de 1974 par les puissances spatiales, l'astre connaît un nouvel intérêt dans les années 1990, deux missions de la NASA — Clementine et Lunar Prospector — découvrant des indices de la présence de glace d'eau, notamment au pôle Sud. À compter de la fin des années 1990, la Lune est la destination principale des sondes spatiales des nouvelles nations spatiales, notamment la Chine, le Japon et l'Inde. De nouvelles missions habitées vers la Lune, voire une colonisation, sont envisagées dans les années 2020.En sa qualité de deuxième objet céleste dans le ciel terrestre par sa magnitude apparente, après le Soleil, et du fait de son cycle régulier de phases correspondant à sa période synodique de 29,5 jours, la Lune sert de référence et d'influence culturelle aux sociétés humaines depuis des temps immémoriaux. Celles-ci se retrouvent dans la langue, les calendriers, l'art et la mythologie. Par exemple, la déesse Luna, dans la mythologie romaine, ou Séléné, dans la mythologie grecque, ont donné respectivement son nom et un adjectif correspondant."

# -*-coding:utf-8 -*-

#tutorial from : https://blog.floydhub.com/a-beginners-guide-on-recurrent-neural-networks-with-pytorch/

import torch
from torch import nn
import numpy as np
import time




def one_hot_encode(sequence, dict_size, seq_len, batch_size):
    # Creating a multi-dimensional array of zeros with the desired output shape
    features = np.zeros((batch_size, seq_len, dict_size), dtype=np.float32)
    
    # Replacing the 0 at the relevant character index with a 1 to represent that character
    for i in range(batch_size):
        for u in range(seq_len):
            features[i, u, sequence[i][u]] = 1
    return features


#return nb_samples samples from input_t & target_t
def sample_seq(nb_samples, total, input_t, target_t):
    global new_input, new_target, indexes
    indexes = np.random.randint(0, total-1, nb_samples)
    input_shape = input_seq.size()
    target_shape = target_seq.size()
    new_input = torch.randn((nb_samples, input_shape[1], input_shape[2]), dtype=torch.float32)
    new_target = torch.randn((nb_samples, target_shape[1]), dtype=torch.float32)

    for a in range(len(indexes)):
        new_input[a] = input_seq[indexes[a]].detach().clone()
        new_target[a] = target_seq[indexes[a]].detach().clone()
    return new_input, new_target



class Model(nn.Module):
    def __init__(self, input_size, output_size, hidden_dim, n_layers):
        super(Model, self).__init__()

        # Defining some parameters
        self.hidden_dim = hidden_dim
        self.n_layers = n_layers

        #Defining the layers
        # RNN Layer
        self.rnn = nn.RNN(input_size, hidden_dim, n_layers, batch_first=True)   #essayer GRU (ou LSTM)
        # Fully connected layer
        self.fc = nn.Linear(hidden_dim, output_size)
    
    def forward(self, x):
        
        batch_size = x.size(0)

        # Initializing hidden state for first input using method defined below
        hidden = self.init_hidden(batch_size)

        # Passing in the input and hidden state into the model and obtaining outputs
        out, hidden = self.rnn(x, hidden)
        
        # Reshaping the outputs such that it can be fit into the fully connected layer
        out = out.contiguous().view(-1, self.hidden_dim)
        out = self.fc(out)
        
        return out, hidden
    
    def init_hidden(self, batch_size):
        # This method generates the first hidden state of zeros which we'll use in the forward pass
        # We'll send the tensor holding the hidden state to the device we specified earlier as well
        hidden = torch.zeros(self.n_layers, batch_size, self.hidden_dim).to(device)
        return hidden


# This function takes in the model and character as arguments and returns the next character prediction and hidden state
def predict(model, character):
    # One-hot encoding our input to fit into the model
    character = np.array([[char2int[c] for c in character]])
    character = one_hot_encode(character, dict_size, character.shape[1], 1)
    character = torch.from_numpy(character)
    character = character.to(device)
    
    out, hidden = model(character)

    prob = nn.functional.softmax(out[-1], dim=0).data
    # Taking the class with the highest probability score from the output
    char_ind = torch.max(prob, dim=0)[1].item()

    return int2char[char_ind], hidden


# This function takes the desired output length and input characters as arguments, returning the produced sentence
def sample(model, out_len, start):
    model.eval() # eval mode
    ## start = start.lower() # WHY ?
    # First off, run through the starting characters
    chars = [ch for ch in start]
    size = out_len - len(chars)
    # Now pass in the previous characters and get a new one
    for ii in range(size):
        char, h = predict(model, chars)
        chars.append(char)

    return ''.join(chars)



def rnn():
	#########################
	# Debut premier section
	#########################


	# torch.cuda.is_available() checks and returns a Boolean True if a GPU is available, else it'll return False
	is_cuda = torch.cuda.is_available()

	# If we have a GPU available, we'll set our device to GPU. We'll use this device variable later in our code.
	global device
	if is_cuda:
		device = torch.device("cuda")
		print("GPU is available")
	else:
		device = torch.device("cpu")
		print("GPU not available, CPU used")


	taille = 100 #length of a sequence # de 100 à 200 généralement (50 pk pas)
	batch_len = 64 # 16 ou 32
	id_last_car = len(txt)-taille #index of the last character to parse for creating the sequences
	text = []


	for i in range(id_last_car):
		text.append(txt[i:i+taille+1])

	"""
	for i in range(0, id_last_car, taille+1):
		text.append(txt[i:i+taille+1])
	"""

	# Join all the sentences together and extract the unique characters from the combined sentences
	chars = set(''.join(text))

	# Creating a dictionary that maps integers to the characters
	int2char = dict(enumerate(chars))

	# Creating another dictionary that maps characters to integers
	char2int = {char: ind for ind, char in int2char.items()}


	# Finding the length of the longest string in our data
	maxlen = len(max(text, key=len))



	# Creating lists that will hold our input and target sequences
	input_seq = []
	target_seq = []

	for i in range(len(text)):
		# Remove last character for input sequence
	  input_seq.append(text[i][:-1])
		
		# Remove first character for target sequence
	  target_seq.append(text[i][1:])
	  #print("Input Sequence: {}\nTarget Sequence: {}".format(input_seq[i], target_seq[i]))


	for i in range(len(text)):
		input_seq[i] = [char2int[character] for character in input_seq[i]]
		target_seq[i] = [char2int[character] for character in target_seq[i]]


	dict_size = len(char2int)
	seq_len = maxlen - 1
	batch_size = len(text)

	##################
	#Fin premiere section
	##################



	###################################
	# Debut 2e section
	###################################
	# Input shape --> (Batch Size, Sequence Length, One-Hot Encoding Size)
	input_seq = one_hot_encode(input_seq, dict_size, seq_len, batch_size)

	input_seq = torch.from_numpy(input_seq)
	target_seq = torch.Tensor(target_seq)
	###################################
	# Fin 2e section
	###################################







	# Instantiate the model with hyperparameters
	model = Model(input_size=dict_size, output_size=dict_size, hidden_dim=512, n_layers=1)
	# We'll also set the model to the device that we defined earlier
	model = model.to(device)

	# set the input_seq ant target_seq to the device used
	input_seq = input_seq.to(device) 
	target_seq = target_seq.to(device)


	# Define hyperparameters
	n_epochs = 5000
	lr=0.001


	# Define Loss, Optimizer
	criterion = nn.CrossEntropyLoss()
	optimizer = torch.optim.Adam(model.parameters(), lr=lr)


	# Training Run
	t1 = time.time()
	for epoch in range(1, n_epochs + 1):
		optimizer.zero_grad() # Clears existing gradients from previous epoch
		#input_sample, target_sample = sample_seq(batch_len, batch_size, input_seq, target_seq)
		output, hidden = model(input_seq)
		loss = criterion(output, target_seq.view(-1).long())

		loss.backward() # Does backpropagation and calculates gradients
		optimizer.step() # Updates the weights accordingly
		
		if epoch%10 == 0:
			t2 = time.time()-t1
			t1 = time.time()
			print('Epoch: {}/{}.............'.format(epoch, n_epochs), end=' ')
			print("Loss: {:.4f}   {:.4f}".format(loss.item(), t2))
	'''
	loss = 1000
	epoch = 1
	t1 = time.time()
	while loss > 0.3:
		optimizer.zero_grad() # Clears existing gradients from previous epoch
		input_sample, target_sample = sample_seq(batch_len, batch_size, input_seq, target_seq)
		output, hidden = model(input_seq)
		loss = criterion(output, target_seq.view(-1).long())
		loss.backward() # Does backpropagation and calculates gradients
		optimizer.step() # Updates the weights accordingly

		epoch += 1
		if epoch%10 == 0:
			t2 = time.time()-t1
			t1 = time.time()
			print('Epoch: {}.............'.format(epoch), end=' ')
			print("Loss: {:.4f}   {:.4f}".format(loss.item(), t2))
	'''

	test_txt = "Les petits pois de la grande-bretagne"
	sample(model, 600, test_txt)